// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIL_MAIL_H_
#define FLATBUFFERS_GENERATED_MAIL_MAIL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Mail {

struct Value;

struct Mail;
struct MailBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Value FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_0_;
  uint8_t data_1_;
  uint8_t data_2_;

 public:
  Value()
      : data_0_(0),
        data_1_(0),
        data_2_(0) {
  }
  Value(uint8_t _data_0, uint8_t _data_1, uint8_t _data_2)
      : data_0_(::flatbuffers::EndianScalar(_data_0)),
        data_1_(::flatbuffers::EndianScalar(_data_1)),
        data_2_(::flatbuffers::EndianScalar(_data_2)) {
  }
  uint8_t data_0() const {
    return ::flatbuffers::EndianScalar(data_0_);
  }
  uint8_t data_1() const {
    return ::flatbuffers::EndianScalar(data_1_);
  }
  uint8_t data_2() const {
    return ::flatbuffers::EndianScalar(data_2_);
  }
};
FLATBUFFERS_STRUCT_END(Value, 3);

struct Mail FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MailBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_CLASSIFICATION = 6,
    VT_CLASSIFICATION_ACTIVE = 8,
    VT_CHANNEL = 10
  };
  const ::flatbuffers::Vector<const Mail::Value *> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<const Mail::Value *> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<float> *classification() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CLASSIFICATION);
  }
  bool classification_active() const {
    return GetField<uint8_t>(VT_CLASSIFICATION_ACTIVE, 0) != 0;
  }
  bool channel() const {
    return GetField<uint8_t>(VT_CHANNEL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyVector(classification()) &&
           VerifyField<uint8_t>(verifier, VT_CLASSIFICATION_ACTIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL, 1) &&
           verifier.EndTable();
  }
};

struct MailBuilder {
  typedef Mail Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<const Mail::Value *>> inputs) {
    fbb_.AddOffset(Mail::VT_INPUTS, inputs);
  }
  void add_classification(::flatbuffers::Offset<::flatbuffers::Vector<float>> classification) {
    fbb_.AddOffset(Mail::VT_CLASSIFICATION, classification);
  }
  void add_classification_active(bool classification_active) {
    fbb_.AddElement<uint8_t>(Mail::VT_CLASSIFICATION_ACTIVE, static_cast<uint8_t>(classification_active), 0);
  }
  void add_channel(bool channel) {
    fbb_.AddElement<uint8_t>(Mail::VT_CHANNEL, static_cast<uint8_t>(channel), 0);
  }
  explicit MailBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Mail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Mail>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Mail> CreateMail(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Mail::Value *>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> classification = 0,
    bool classification_active = false,
    bool channel = false) {
  MailBuilder builder_(_fbb);
  builder_.add_classification(classification);
  builder_.add_inputs(inputs);
  builder_.add_channel(channel);
  builder_.add_classification_active(classification_active);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Mail> CreateMailDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Mail::Value> *inputs = nullptr,
    const std::vector<float> *classification = nullptr,
    bool classification_active = false,
    bool channel = false) {
  auto inputs__ = inputs ? _fbb.CreateVectorOfStructs<Mail::Value>(*inputs) : 0;
  auto classification__ = classification ? _fbb.CreateVector<float>(*classification) : 0;
  return Mail::CreateMail(
      _fbb,
      inputs__,
      classification__,
      classification_active,
      channel);
}

inline const Mail::Mail *GetMail(const void *buf) {
  return ::flatbuffers::GetRoot<Mail::Mail>(buf);
}

inline const Mail::Mail *GetSizePrefixedMail(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Mail::Mail>(buf);
}

inline bool VerifyMailBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Mail::Mail>(nullptr);
}

inline bool VerifySizePrefixedMailBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Mail::Mail>(nullptr);
}

inline void FinishMailBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Mail::Mail> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMailBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Mail::Mail> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Mail

#endif  // FLATBUFFERS_GENERATED_MAIL_MAIL_H_
