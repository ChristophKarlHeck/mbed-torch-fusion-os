// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROGRAM_EXECUTORCH_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_PROGRAM_EXECUTORCH_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

#include "scalar_type_generated.h"

namespace executorch_flatbuffer {

struct ContainerMetadata;
struct ContainerMetadataBuilder;

struct Null;
struct NullBuilder;

struct AllocationDetails;
struct AllocationDetailsBuilder;

struct Tensor;
struct TensorBuilder;

struct Int;
struct IntBuilder;

struct Bool;
struct BoolBuilder;

struct Double;
struct DoubleBuilder;

struct String;
struct StringBuilder;

struct IntList;
struct IntListBuilder;

struct DoubleList;
struct DoubleListBuilder;

struct BoolList;
struct BoolListBuilder;

struct TensorList;
struct TensorListBuilder;

struct OptionalTensorList;
struct OptionalTensorListBuilder;

struct EValue;
struct EValueBuilder;

struct Operator;
struct OperatorBuilder;

struct KernelCall;
struct KernelCallBuilder;

struct DelegateCall;
struct DelegateCallBuilder;

struct MoveCall;
struct MoveCallBuilder;

struct JumpFalseCall;
struct JumpFalseCallBuilder;

struct FreeCall;
struct FreeCallBuilder;

struct Instruction;
struct InstructionBuilder;

struct Frame;
struct FrameBuilder;

struct FrameList;
struct FrameListBuilder;

struct BackendDelegateDataReference;
struct BackendDelegateDataReferenceBuilder;

struct CompileSpec;
struct CompileSpecBuilder;

struct BackendDelegate;
struct BackendDelegateBuilder;

struct Chain;
struct ChainBuilder;

struct ExecutionPlan;
struct ExecutionPlanBuilder;

struct Buffer;
struct BufferBuilder;

struct BackendDelegateInlineData;
struct BackendDelegateInlineDataBuilder;

struct DataSegment;
struct DataSegmentBuilder;

struct SubsegmentOffsets;
struct SubsegmentOffsetsBuilder;

struct Program;
struct ProgramBuilder;

enum class TensorShapeDynamism : int8_t {
  STATIC = 0,
  DYNAMIC_BOUND = 1,
  DYNAMIC_UNBOUND = 2,
  MIN = STATIC,
  MAX = DYNAMIC_UNBOUND
};

inline const TensorShapeDynamism (&EnumValuesTensorShapeDynamism())[3] {
  static const TensorShapeDynamism values[] = {
    TensorShapeDynamism::STATIC,
    TensorShapeDynamism::DYNAMIC_BOUND,
    TensorShapeDynamism::DYNAMIC_UNBOUND
  };
  return values;
}

inline const char * const *EnumNamesTensorShapeDynamism() {
  static const char * const names[4] = {
    "STATIC",
    "DYNAMIC_BOUND",
    "DYNAMIC_UNBOUND",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorShapeDynamism(TensorShapeDynamism e) {
  if (::flatbuffers::IsOutRange(e, TensorShapeDynamism::STATIC, TensorShapeDynamism::DYNAMIC_UNBOUND)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorShapeDynamism()[index];
}

enum class KernelTypes : uint8_t {
  NONE = 0,
  Null = 1,
  Int = 2,
  Bool = 3,
  Double = 4,
  Tensor = 5,
  String = 6,
  IntList = 7,
  DoubleList = 8,
  BoolList = 9,
  TensorList = 10,
  OptionalTensorList = 11,
  MIN = NONE,
  MAX = OptionalTensorList
};

inline const KernelTypes (&EnumValuesKernelTypes())[12] {
  static const KernelTypes values[] = {
    KernelTypes::NONE,
    KernelTypes::Null,
    KernelTypes::Int,
    KernelTypes::Bool,
    KernelTypes::Double,
    KernelTypes::Tensor,
    KernelTypes::String,
    KernelTypes::IntList,
    KernelTypes::DoubleList,
    KernelTypes::BoolList,
    KernelTypes::TensorList,
    KernelTypes::OptionalTensorList
  };
  return values;
}

inline const char * const *EnumNamesKernelTypes() {
  static const char * const names[13] = {
    "NONE",
    "Null",
    "Int",
    "Bool",
    "Double",
    "Tensor",
    "String",
    "IntList",
    "DoubleList",
    "BoolList",
    "TensorList",
    "OptionalTensorList",
    nullptr
  };
  return names;
}

inline const char *EnumNameKernelTypes(KernelTypes e) {
  if (::flatbuffers::IsOutRange(e, KernelTypes::NONE, KernelTypes::OptionalTensorList)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKernelTypes()[index];
}

template<typename T> struct KernelTypesTraits {
  static const KernelTypes enum_value = KernelTypes::NONE;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::Null> {
  static const KernelTypes enum_value = KernelTypes::Null;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::Int> {
  static const KernelTypes enum_value = KernelTypes::Int;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::Bool> {
  static const KernelTypes enum_value = KernelTypes::Bool;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::Double> {
  static const KernelTypes enum_value = KernelTypes::Double;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::Tensor> {
  static const KernelTypes enum_value = KernelTypes::Tensor;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::String> {
  static const KernelTypes enum_value = KernelTypes::String;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::IntList> {
  static const KernelTypes enum_value = KernelTypes::IntList;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::DoubleList> {
  static const KernelTypes enum_value = KernelTypes::DoubleList;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::BoolList> {
  static const KernelTypes enum_value = KernelTypes::BoolList;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::TensorList> {
  static const KernelTypes enum_value = KernelTypes::TensorList;
};

template<> struct KernelTypesTraits<executorch_flatbuffer::OptionalTensorList> {
  static const KernelTypes enum_value = KernelTypes::OptionalTensorList;
};

bool VerifyKernelTypes(::flatbuffers::Verifier &verifier, const void *obj, KernelTypes type);
bool VerifyKernelTypesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<KernelTypes> *types);

enum class InstructionArguments : uint8_t {
  NONE = 0,
  KernelCall = 1,
  DelegateCall = 2,
  MoveCall = 3,
  JumpFalseCall = 4,
  FreeCall = 5,
  MIN = NONE,
  MAX = FreeCall
};

inline const InstructionArguments (&EnumValuesInstructionArguments())[6] {
  static const InstructionArguments values[] = {
    InstructionArguments::NONE,
    InstructionArguments::KernelCall,
    InstructionArguments::DelegateCall,
    InstructionArguments::MoveCall,
    InstructionArguments::JumpFalseCall,
    InstructionArguments::FreeCall
  };
  return values;
}

inline const char * const *EnumNamesInstructionArguments() {
  static const char * const names[7] = {
    "NONE",
    "KernelCall",
    "DelegateCall",
    "MoveCall",
    "JumpFalseCall",
    "FreeCall",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstructionArguments(InstructionArguments e) {
  if (::flatbuffers::IsOutRange(e, InstructionArguments::NONE, InstructionArguments::FreeCall)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInstructionArguments()[index];
}

template<typename T> struct InstructionArgumentsTraits {
  static const InstructionArguments enum_value = InstructionArguments::NONE;
};

template<> struct InstructionArgumentsTraits<executorch_flatbuffer::KernelCall> {
  static const InstructionArguments enum_value = InstructionArguments::KernelCall;
};

template<> struct InstructionArgumentsTraits<executorch_flatbuffer::DelegateCall> {
  static const InstructionArguments enum_value = InstructionArguments::DelegateCall;
};

template<> struct InstructionArgumentsTraits<executorch_flatbuffer::MoveCall> {
  static const InstructionArguments enum_value = InstructionArguments::MoveCall;
};

template<> struct InstructionArgumentsTraits<executorch_flatbuffer::JumpFalseCall> {
  static const InstructionArguments enum_value = InstructionArguments::JumpFalseCall;
};

template<> struct InstructionArgumentsTraits<executorch_flatbuffer::FreeCall> {
  static const InstructionArguments enum_value = InstructionArguments::FreeCall;
};

bool VerifyInstructionArguments(::flatbuffers::Verifier &verifier, const void *obj, InstructionArguments type);
bool VerifyInstructionArgumentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<InstructionArguments> *types);

enum class DataLocation : int8_t {
  INLINE = 0,
  SEGMENT = 1,
  MIN = INLINE,
  MAX = SEGMENT
};

inline const DataLocation (&EnumValuesDataLocation())[2] {
  static const DataLocation values[] = {
    DataLocation::INLINE,
    DataLocation::SEGMENT
  };
  return values;
}

inline const char * const *EnumNamesDataLocation() {
  static const char * const names[3] = {
    "INLINE",
    "SEGMENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataLocation(DataLocation e) {
  if (::flatbuffers::IsOutRange(e, DataLocation::INLINE, DataLocation::SEGMENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataLocation()[index];
}

struct ContainerMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContainerMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCODED_INP_STR = 4,
    VT_ENCODED_OUT_STR = 6
  };
  const ::flatbuffers::String *encoded_inp_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENCODED_INP_STR);
  }
  ::flatbuffers::String *mutable_encoded_inp_str() {
    return GetPointer<::flatbuffers::String *>(VT_ENCODED_INP_STR);
  }
  const ::flatbuffers::String *encoded_out_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENCODED_OUT_STR);
  }
  ::flatbuffers::String *mutable_encoded_out_str() {
    return GetPointer<::flatbuffers::String *>(VT_ENCODED_OUT_STR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENCODED_INP_STR) &&
           verifier.VerifyString(encoded_inp_str()) &&
           VerifyOffset(verifier, VT_ENCODED_OUT_STR) &&
           verifier.VerifyString(encoded_out_str()) &&
           verifier.EndTable();
  }
};

struct ContainerMetadataBuilder {
  typedef ContainerMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_encoded_inp_str(::flatbuffers::Offset<::flatbuffers::String> encoded_inp_str) {
    fbb_.AddOffset(ContainerMetadata::VT_ENCODED_INP_STR, encoded_inp_str);
  }
  void add_encoded_out_str(::flatbuffers::Offset<::flatbuffers::String> encoded_out_str) {
    fbb_.AddOffset(ContainerMetadata::VT_ENCODED_OUT_STR, encoded_out_str);
  }
  explicit ContainerMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContainerMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContainerMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContainerMetadata> CreateContainerMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> encoded_inp_str = 0,
    ::flatbuffers::Offset<::flatbuffers::String> encoded_out_str = 0) {
  ContainerMetadataBuilder builder_(_fbb);
  builder_.add_encoded_out_str(encoded_out_str);
  builder_.add_encoded_inp_str(encoded_inp_str);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContainerMetadata> CreateContainerMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *encoded_inp_str = nullptr,
    const char *encoded_out_str = nullptr) {
  auto encoded_inp_str__ = encoded_inp_str ? _fbb.CreateString(encoded_inp_str) : 0;
  auto encoded_out_str__ = encoded_out_str ? _fbb.CreateString(encoded_out_str) : 0;
  return executorch_flatbuffer::CreateContainerMetadata(
      _fbb,
      encoded_inp_str__,
      encoded_out_str__);
}

struct Null FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NullBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NullBuilder {
  typedef Null Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Null> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Null>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Null> CreateNull(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NullBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AllocationDetails FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AllocationDetailsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEMORY_ID = 4,
    VT_MEMORY_OFFSET_LOW = 6,
    VT_MEMORY_OFFSET_HIGH = 8
  };
  uint32_t memory_id() const {
    return GetField<uint32_t>(VT_MEMORY_ID, 0);
  }
  bool mutate_memory_id(uint32_t _memory_id = 0) {
    return SetField<uint32_t>(VT_MEMORY_ID, _memory_id, 0);
  }
  uint32_t memory_offset_low() const {
    return GetField<uint32_t>(VT_MEMORY_OFFSET_LOW, 0);
  }
  bool mutate_memory_offset_low(uint32_t _memory_offset_low = 0) {
    return SetField<uint32_t>(VT_MEMORY_OFFSET_LOW, _memory_offset_low, 0);
  }
  uint32_t memory_offset_high() const {
    return GetField<uint32_t>(VT_MEMORY_OFFSET_HIGH, 0);
  }
  bool mutate_memory_offset_high(uint32_t _memory_offset_high = 0) {
    return SetField<uint32_t>(VT_MEMORY_OFFSET_HIGH, _memory_offset_high, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MEMORY_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_MEMORY_OFFSET_LOW, 4) &&
           VerifyField<uint32_t>(verifier, VT_MEMORY_OFFSET_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct AllocationDetailsBuilder {
  typedef AllocationDetails Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_memory_id(uint32_t memory_id) {
    fbb_.AddElement<uint32_t>(AllocationDetails::VT_MEMORY_ID, memory_id, 0);
  }
  void add_memory_offset_low(uint32_t memory_offset_low) {
    fbb_.AddElement<uint32_t>(AllocationDetails::VT_MEMORY_OFFSET_LOW, memory_offset_low, 0);
  }
  void add_memory_offset_high(uint32_t memory_offset_high) {
    fbb_.AddElement<uint32_t>(AllocationDetails::VT_MEMORY_OFFSET_HIGH, memory_offset_high, 0);
  }
  explicit AllocationDetailsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AllocationDetails> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AllocationDetails>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AllocationDetails> CreateAllocationDetails(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t memory_id = 0,
    uint32_t memory_offset_low = 0,
    uint32_t memory_offset_high = 0) {
  AllocationDetailsBuilder builder_(_fbb);
  builder_.add_memory_offset_high(memory_offset_high);
  builder_.add_memory_offset_low(memory_offset_low);
  builder_.add_memory_id(memory_id);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALAR_TYPE = 4,
    VT_STORAGE_OFFSET = 6,
    VT_SIZES = 8,
    VT_DIM_ORDER = 10,
    VT_REQUIRES_GRAD = 12,
    VT_CONSTANT_BUFFER_IDX = 14,
    VT_ALLOCATION_INFO = 16,
    VT_LAYOUT = 18,
    VT_SHAPE_DYNAMISM = 20
  };
  executorch_flatbuffer::ScalarType scalar_type() const {
    return static_cast<executorch_flatbuffer::ScalarType>(GetField<int8_t>(VT_SCALAR_TYPE, 0));
  }
  bool mutate_scalar_type(executorch_flatbuffer::ScalarType _scalar_type = static_cast<executorch_flatbuffer::ScalarType>(0)) {
    return SetField<int8_t>(VT_SCALAR_TYPE, static_cast<int8_t>(_scalar_type), 0);
  }
  int32_t storage_offset() const {
    return GetField<int32_t>(VT_STORAGE_OFFSET, 0);
  }
  bool mutate_storage_offset(int32_t _storage_offset = 0) {
    return SetField<int32_t>(VT_STORAGE_OFFSET, _storage_offset, 0);
  }
  const ::flatbuffers::Vector<int32_t> *sizes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  ::flatbuffers::Vector<int32_t> *mutable_sizes() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  const ::flatbuffers::Vector<uint8_t> *dim_order() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DIM_ORDER);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_dim_order() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DIM_ORDER);
  }
  bool requires_grad() const {
    return GetField<uint8_t>(VT_REQUIRES_GRAD, 0) != 0;
  }
  bool mutate_requires_grad(bool _requires_grad = 0) {
    return SetField<uint8_t>(VT_REQUIRES_GRAD, static_cast<uint8_t>(_requires_grad), 0);
  }
  uint32_t constant_buffer_idx() const {
    return GetField<uint32_t>(VT_CONSTANT_BUFFER_IDX, 0);
  }
  bool mutate_constant_buffer_idx(uint32_t _constant_buffer_idx = 0) {
    return SetField<uint32_t>(VT_CONSTANT_BUFFER_IDX, _constant_buffer_idx, 0);
  }
  const executorch_flatbuffer::AllocationDetails *allocation_info() const {
    return GetPointer<const executorch_flatbuffer::AllocationDetails *>(VT_ALLOCATION_INFO);
  }
  executorch_flatbuffer::AllocationDetails *mutable_allocation_info() {
    return GetPointer<executorch_flatbuffer::AllocationDetails *>(VT_ALLOCATION_INFO);
  }
  int8_t layout() const {
    return GetField<int8_t>(VT_LAYOUT, 0);
  }
  bool mutate_layout(int8_t _layout = 0) {
    return SetField<int8_t>(VT_LAYOUT, _layout, 0);
  }
  executorch_flatbuffer::TensorShapeDynamism shape_dynamism() const {
    return static_cast<executorch_flatbuffer::TensorShapeDynamism>(GetField<int8_t>(VT_SHAPE_DYNAMISM, 0));
  }
  bool mutate_shape_dynamism(executorch_flatbuffer::TensorShapeDynamism _shape_dynamism = static_cast<executorch_flatbuffer::TensorShapeDynamism>(0)) {
    return SetField<int8_t>(VT_SHAPE_DYNAMISM, static_cast<int8_t>(_shape_dynamism), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SCALAR_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_OFFSET, 4) &&
           VerifyOffset(verifier, VT_SIZES) &&
           verifier.VerifyVector(sizes()) &&
           VerifyOffset(verifier, VT_DIM_ORDER) &&
           verifier.VerifyVector(dim_order()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRES_GRAD, 1) &&
           VerifyField<uint32_t>(verifier, VT_CONSTANT_BUFFER_IDX, 4) &&
           VerifyOffset(verifier, VT_ALLOCATION_INFO) &&
           verifier.VerifyTable(allocation_info()) &&
           VerifyField<int8_t>(verifier, VT_LAYOUT, 1) &&
           VerifyField<int8_t>(verifier, VT_SHAPE_DYNAMISM, 1) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scalar_type(executorch_flatbuffer::ScalarType scalar_type) {
    fbb_.AddElement<int8_t>(Tensor::VT_SCALAR_TYPE, static_cast<int8_t>(scalar_type), 0);
  }
  void add_storage_offset(int32_t storage_offset) {
    fbb_.AddElement<int32_t>(Tensor::VT_STORAGE_OFFSET, storage_offset, 0);
  }
  void add_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> sizes) {
    fbb_.AddOffset(Tensor::VT_SIZES, sizes);
  }
  void add_dim_order(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> dim_order) {
    fbb_.AddOffset(Tensor::VT_DIM_ORDER, dim_order);
  }
  void add_requires_grad(bool requires_grad) {
    fbb_.AddElement<uint8_t>(Tensor::VT_REQUIRES_GRAD, static_cast<uint8_t>(requires_grad), 0);
  }
  void add_constant_buffer_idx(uint32_t constant_buffer_idx) {
    fbb_.AddElement<uint32_t>(Tensor::VT_CONSTANT_BUFFER_IDX, constant_buffer_idx, 0);
  }
  void add_allocation_info(::flatbuffers::Offset<executorch_flatbuffer::AllocationDetails> allocation_info) {
    fbb_.AddOffset(Tensor::VT_ALLOCATION_INFO, allocation_info);
  }
  void add_layout(int8_t layout) {
    fbb_.AddElement<int8_t>(Tensor::VT_LAYOUT, layout, 0);
  }
  void add_shape_dynamism(executorch_flatbuffer::TensorShapeDynamism shape_dynamism) {
    fbb_.AddElement<int8_t>(Tensor::VT_SHAPE_DYNAMISM, static_cast<int8_t>(shape_dynamism), 0);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    executorch_flatbuffer::ScalarType scalar_type = executorch_flatbuffer::ScalarType::BYTE,
    int32_t storage_offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> sizes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> dim_order = 0,
    bool requires_grad = false,
    uint32_t constant_buffer_idx = 0,
    ::flatbuffers::Offset<executorch_flatbuffer::AllocationDetails> allocation_info = 0,
    int8_t layout = 0,
    executorch_flatbuffer::TensorShapeDynamism shape_dynamism = executorch_flatbuffer::TensorShapeDynamism::STATIC) {
  TensorBuilder builder_(_fbb);
  builder_.add_allocation_info(allocation_info);
  builder_.add_constant_buffer_idx(constant_buffer_idx);
  builder_.add_dim_order(dim_order);
  builder_.add_sizes(sizes);
  builder_.add_storage_offset(storage_offset);
  builder_.add_shape_dynamism(shape_dynamism);
  builder_.add_layout(layout);
  builder_.add_requires_grad(requires_grad);
  builder_.add_scalar_type(scalar_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    executorch_flatbuffer::ScalarType scalar_type = executorch_flatbuffer::ScalarType::BYTE,
    int32_t storage_offset = 0,
    const std::vector<int32_t> *sizes = nullptr,
    const std::vector<uint8_t> *dim_order = nullptr,
    bool requires_grad = false,
    uint32_t constant_buffer_idx = 0,
    ::flatbuffers::Offset<executorch_flatbuffer::AllocationDetails> allocation_info = 0,
    int8_t layout = 0,
    executorch_flatbuffer::TensorShapeDynamism shape_dynamism = executorch_flatbuffer::TensorShapeDynamism::STATIC) {
  auto sizes__ = sizes ? _fbb.CreateVector<int32_t>(*sizes) : 0;
  auto dim_order__ = dim_order ? _fbb.CreateVector<uint8_t>(*dim_order) : 0;
  return executorch_flatbuffer::CreateTensor(
      _fbb,
      scalar_type,
      storage_offset,
      sizes__,
      dim_order__,
      requires_grad,
      constant_buffer_idx,
      allocation_info,
      layout,
      shape_dynamism);
}

struct Int FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT_VAL = 4
  };
  int64_t int_val() const {
    return GetField<int64_t>(VT_INT_VAL, 0);
  }
  bool mutate_int_val(int64_t _int_val = 0) {
    return SetField<int64_t>(VT_INT_VAL, _int_val, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_INT_VAL, 8) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_int_val(int64_t int_val) {
    fbb_.AddElement<int64_t>(Int::VT_INT_VAL, int_val, 0);
  }
  explicit IntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int> CreateInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t int_val = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_int_val(int_val);
  return builder_.Finish();
}

struct Bool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOL_VAL = 4
  };
  bool bool_val() const {
    return GetField<uint8_t>(VT_BOOL_VAL, 0) != 0;
  }
  bool mutate_bool_val(bool _bool_val = 0) {
    return SetField<uint8_t>(VT_BOOL_VAL, static_cast<uint8_t>(_bool_val), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOL_VAL, 1) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  typedef Bool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bool_val(bool bool_val) {
    fbb_.AddElement<uint8_t>(Bool::VT_BOOL_VAL, static_cast<uint8_t>(bool_val), 0);
  }
  explicit BoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bool> CreateBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool bool_val = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_bool_val(bool_val);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOUBLE_VAL = 4
  };
  double double_val() const {
    return GetField<double>(VT_DOUBLE_VAL, 0.0);
  }
  bool mutate_double_val(double _double_val = 0.0) {
    return SetField<double>(VT_DOUBLE_VAL, _double_val, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DOUBLE_VAL, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_double_val(double double_val) {
    fbb_.AddElement<double>(Double::VT_DOUBLE_VAL, double_val, 0.0);
  }
  explicit DoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Double> CreateDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double double_val = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_double_val(double_val);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRING_VAL = 4
  };
  const ::flatbuffers::String *string_val() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_VAL);
  }
  ::flatbuffers::String *mutable_string_val() {
    return GetPointer<::flatbuffers::String *>(VT_STRING_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRING_VAL) &&
           verifier.VerifyString(string_val()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_string_val(::flatbuffers::Offset<::flatbuffers::String> string_val) {
    fbb_.AddOffset(String::VT_STRING_VAL, string_val);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> string_val = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_string_val(string_val);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *string_val = nullptr) {
  auto string_val__ = string_val ? _fbb.CreateString(string_val) : 0;
  return executorch_flatbuffer::CreateString(
      _fbb,
      string_val__);
}

struct IntList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<int64_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<int64_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct IntListBuilder {
  typedef IntList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> items) {
    fbb_.AddOffset(IntList::VT_ITEMS, items);
  }
  explicit IntListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntList> CreateIntList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> items = 0) {
  IntListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntList> CreateIntListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int64_t>(*items) : 0;
  return executorch_flatbuffer::CreateIntList(
      _fbb,
      items__);
}

struct DoubleList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<double> *items() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<double> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct DoubleListBuilder {
  typedef DoubleList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<double>> items) {
    fbb_.AddOffset(DoubleList::VT_ITEMS, items);
  }
  explicit DoubleListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DoubleList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DoubleList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DoubleList> CreateDoubleList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> items = 0) {
  DoubleListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DoubleList> CreateDoubleListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<double>(*items) : 0;
  return executorch_flatbuffer::CreateDoubleList(
      _fbb,
      items__);
}

struct BoolList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct BoolListBuilder {
  typedef BoolList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(BoolList::VT_ITEMS, items);
  }
  explicit BoolListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolList> CreateBoolList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> items = 0) {
  BoolListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoolList> CreateBoolListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return executorch_flatbuffer::CreateBoolList(
      _fbb,
      items__);
}

struct TensorList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct TensorListBuilder {
  typedef TensorList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items) {
    fbb_.AddOffset(TensorList::VT_ITEMS, items);
  }
  explicit TensorListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorList> CreateTensorList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items = 0) {
  TensorListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorList> CreateTensorListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int32_t>(*items) : 0;
  return executorch_flatbuffer::CreateTensorList(
      _fbb,
      items__);
}

struct OptionalTensorList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalTensorListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct OptionalTensorListBuilder {
  typedef OptionalTensorList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items) {
    fbb_.AddOffset(OptionalTensorList::VT_ITEMS, items);
  }
  explicit OptionalTensorListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalTensorList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalTensorList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalTensorList> CreateOptionalTensorList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items = 0) {
  OptionalTensorListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OptionalTensorList> CreateOptionalTensorListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int32_t>(*items) : 0;
  return executorch_flatbuffer::CreateOptionalTensorList(
      _fbb,
      items__);
}

struct EValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  executorch_flatbuffer::KernelTypes val_type() const {
    return static_cast<executorch_flatbuffer::KernelTypes>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const executorch_flatbuffer::Null *val_as_Null() const {
    return val_type() == executorch_flatbuffer::KernelTypes::Null ? static_cast<const executorch_flatbuffer::Null *>(val()) : nullptr;
  }
  const executorch_flatbuffer::Int *val_as_Int() const {
    return val_type() == executorch_flatbuffer::KernelTypes::Int ? static_cast<const executorch_flatbuffer::Int *>(val()) : nullptr;
  }
  const executorch_flatbuffer::Bool *val_as_Bool() const {
    return val_type() == executorch_flatbuffer::KernelTypes::Bool ? static_cast<const executorch_flatbuffer::Bool *>(val()) : nullptr;
  }
  const executorch_flatbuffer::Double *val_as_Double() const {
    return val_type() == executorch_flatbuffer::KernelTypes::Double ? static_cast<const executorch_flatbuffer::Double *>(val()) : nullptr;
  }
  const executorch_flatbuffer::Tensor *val_as_Tensor() const {
    return val_type() == executorch_flatbuffer::KernelTypes::Tensor ? static_cast<const executorch_flatbuffer::Tensor *>(val()) : nullptr;
  }
  const executorch_flatbuffer::String *val_as_String() const {
    return val_type() == executorch_flatbuffer::KernelTypes::String ? static_cast<const executorch_flatbuffer::String *>(val()) : nullptr;
  }
  const executorch_flatbuffer::IntList *val_as_IntList() const {
    return val_type() == executorch_flatbuffer::KernelTypes::IntList ? static_cast<const executorch_flatbuffer::IntList *>(val()) : nullptr;
  }
  const executorch_flatbuffer::DoubleList *val_as_DoubleList() const {
    return val_type() == executorch_flatbuffer::KernelTypes::DoubleList ? static_cast<const executorch_flatbuffer::DoubleList *>(val()) : nullptr;
  }
  const executorch_flatbuffer::BoolList *val_as_BoolList() const {
    return val_type() == executorch_flatbuffer::KernelTypes::BoolList ? static_cast<const executorch_flatbuffer::BoolList *>(val()) : nullptr;
  }
  const executorch_flatbuffer::TensorList *val_as_TensorList() const {
    return val_type() == executorch_flatbuffer::KernelTypes::TensorList ? static_cast<const executorch_flatbuffer::TensorList *>(val()) : nullptr;
  }
  const executorch_flatbuffer::OptionalTensorList *val_as_OptionalTensorList() const {
    return val_type() == executorch_flatbuffer::KernelTypes::OptionalTensorList ? static_cast<const executorch_flatbuffer::OptionalTensorList *>(val()) : nullptr;
  }
  void *mutable_val() {
    return GetPointer<void *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyKernelTypes(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const executorch_flatbuffer::Null *EValue::val_as<executorch_flatbuffer::Null>() const {
  return val_as_Null();
}

template<> inline const executorch_flatbuffer::Int *EValue::val_as<executorch_flatbuffer::Int>() const {
  return val_as_Int();
}

template<> inline const executorch_flatbuffer::Bool *EValue::val_as<executorch_flatbuffer::Bool>() const {
  return val_as_Bool();
}

template<> inline const executorch_flatbuffer::Double *EValue::val_as<executorch_flatbuffer::Double>() const {
  return val_as_Double();
}

template<> inline const executorch_flatbuffer::Tensor *EValue::val_as<executorch_flatbuffer::Tensor>() const {
  return val_as_Tensor();
}

template<> inline const executorch_flatbuffer::String *EValue::val_as<executorch_flatbuffer::String>() const {
  return val_as_String();
}

template<> inline const executorch_flatbuffer::IntList *EValue::val_as<executorch_flatbuffer::IntList>() const {
  return val_as_IntList();
}

template<> inline const executorch_flatbuffer::DoubleList *EValue::val_as<executorch_flatbuffer::DoubleList>() const {
  return val_as_DoubleList();
}

template<> inline const executorch_flatbuffer::BoolList *EValue::val_as<executorch_flatbuffer::BoolList>() const {
  return val_as_BoolList();
}

template<> inline const executorch_flatbuffer::TensorList *EValue::val_as<executorch_flatbuffer::TensorList>() const {
  return val_as_TensorList();
}

template<> inline const executorch_flatbuffer::OptionalTensorList *EValue::val_as<executorch_flatbuffer::OptionalTensorList>() const {
  return val_as_OptionalTensorList();
}

struct EValueBuilder {
  typedef EValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(executorch_flatbuffer::KernelTypes val_type) {
    fbb_.AddElement<uint8_t>(EValue::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(EValue::VT_VAL, val);
  }
  explicit EValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EValue> CreateEValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    executorch_flatbuffer::KernelTypes val_type = executorch_flatbuffer::KernelTypes::NONE,
    ::flatbuffers::Offset<void> val = 0) {
  EValueBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OVERLOAD = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *overload() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OVERLOAD);
  }
  ::flatbuffers::String *mutable_overload() {
    return GetPointer<::flatbuffers::String *>(VT_OVERLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OVERLOAD) &&
           verifier.VerifyString(overload()) &&
           verifier.EndTable();
  }
};

struct OperatorBuilder {
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Operator::VT_NAME, name);
  }
  void add_overload(::flatbuffers::Offset<::flatbuffers::String> overload) {
    fbb_.AddOffset(Operator::VT_OVERLOAD, overload);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> overload = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_overload(overload);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *overload = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto overload__ = overload ? _fbb.CreateString(overload) : 0;
  return executorch_flatbuffer::CreateOperator(
      _fbb,
      name__,
      overload__);
}

struct KernelCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KernelCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_INDEX = 4,
    VT_ARGS = 6
  };
  int32_t op_index() const {
    return GetField<int32_t>(VT_OP_INDEX, 0);
  }
  bool mutate_op_index(int32_t _op_index = 0) {
    return SetField<int32_t>(VT_OP_INDEX, _op_index, 0);
  }
  const ::flatbuffers::Vector<int32_t> *args() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_args() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OP_INDEX, 4) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.EndTable();
  }
};

struct KernelCallBuilder {
  typedef KernelCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_index(int32_t op_index) {
    fbb_.AddElement<int32_t>(KernelCall::VT_OP_INDEX, op_index, 0);
  }
  void add_args(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> args) {
    fbb_.AddOffset(KernelCall::VT_ARGS, args);
  }
  explicit KernelCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KernelCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KernelCall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KernelCall> CreateKernelCall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t op_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> args = 0) {
  KernelCallBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_op_index(op_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KernelCall> CreateKernelCallDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t op_index = 0,
    const std::vector<int32_t> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVector<int32_t>(*args) : 0;
  return executorch_flatbuffer::CreateKernelCall(
      _fbb,
      op_index,
      args__);
}

struct DelegateCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DelegateCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DELEGATE_INDEX = 4,
    VT_ARGS = 6
  };
  int32_t delegate_index() const {
    return GetField<int32_t>(VT_DELEGATE_INDEX, 0);
  }
  bool mutate_delegate_index(int32_t _delegate_index = 0) {
    return SetField<int32_t>(VT_DELEGATE_INDEX, _delegate_index, 0);
  }
  const ::flatbuffers::Vector<int32_t> *args() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_args() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DELEGATE_INDEX, 4) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.EndTable();
  }
};

struct DelegateCallBuilder {
  typedef DelegateCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_delegate_index(int32_t delegate_index) {
    fbb_.AddElement<int32_t>(DelegateCall::VT_DELEGATE_INDEX, delegate_index, 0);
  }
  void add_args(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> args) {
    fbb_.AddOffset(DelegateCall::VT_ARGS, args);
  }
  explicit DelegateCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DelegateCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DelegateCall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DelegateCall> CreateDelegateCall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t delegate_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> args = 0) {
  DelegateCallBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_delegate_index(delegate_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DelegateCall> CreateDelegateCallDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t delegate_index = 0,
    const std::vector<int32_t> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVector<int32_t>(*args) : 0;
  return executorch_flatbuffer::CreateDelegateCall(
      _fbb,
      delegate_index,
      args__);
}

struct MoveCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOVE_FROM = 4,
    VT_MOVE_TO = 6
  };
  int32_t move_from() const {
    return GetField<int32_t>(VT_MOVE_FROM, 0);
  }
  bool mutate_move_from(int32_t _move_from = 0) {
    return SetField<int32_t>(VT_MOVE_FROM, _move_from, 0);
  }
  int32_t move_to() const {
    return GetField<int32_t>(VT_MOVE_TO, 0);
  }
  bool mutate_move_to(int32_t _move_to = 0) {
    return SetField<int32_t>(VT_MOVE_TO, _move_to, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MOVE_FROM, 4) &&
           VerifyField<int32_t>(verifier, VT_MOVE_TO, 4) &&
           verifier.EndTable();
  }
};

struct MoveCallBuilder {
  typedef MoveCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_move_from(int32_t move_from) {
    fbb_.AddElement<int32_t>(MoveCall::VT_MOVE_FROM, move_from, 0);
  }
  void add_move_to(int32_t move_to) {
    fbb_.AddElement<int32_t>(MoveCall::VT_MOVE_TO, move_to, 0);
  }
  explicit MoveCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveCall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveCall> CreateMoveCall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t move_from = 0,
    int32_t move_to = 0) {
  MoveCallBuilder builder_(_fbb);
  builder_.add_move_to(move_to);
  builder_.add_move_from(move_from);
  return builder_.Finish();
}

struct JumpFalseCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JumpFalseCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_VALUE_INDEX = 4,
    VT_DESTINATION_INSTRUCTION = 6
  };
  int32_t cond_value_index() const {
    return GetField<int32_t>(VT_COND_VALUE_INDEX, 0);
  }
  bool mutate_cond_value_index(int32_t _cond_value_index = 0) {
    return SetField<int32_t>(VT_COND_VALUE_INDEX, _cond_value_index, 0);
  }
  int32_t destination_instruction() const {
    return GetField<int32_t>(VT_DESTINATION_INSTRUCTION, 0);
  }
  bool mutate_destination_instruction(int32_t _destination_instruction = 0) {
    return SetField<int32_t>(VT_DESTINATION_INSTRUCTION, _destination_instruction, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_VALUE_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_DESTINATION_INSTRUCTION, 4) &&
           verifier.EndTable();
  }
};

struct JumpFalseCallBuilder {
  typedef JumpFalseCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_value_index(int32_t cond_value_index) {
    fbb_.AddElement<int32_t>(JumpFalseCall::VT_COND_VALUE_INDEX, cond_value_index, 0);
  }
  void add_destination_instruction(int32_t destination_instruction) {
    fbb_.AddElement<int32_t>(JumpFalseCall::VT_DESTINATION_INSTRUCTION, destination_instruction, 0);
  }
  explicit JumpFalseCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JumpFalseCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JumpFalseCall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JumpFalseCall> CreateJumpFalseCall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_value_index = 0,
    int32_t destination_instruction = 0) {
  JumpFalseCallBuilder builder_(_fbb);
  builder_.add_destination_instruction(destination_instruction);
  builder_.add_cond_value_index(cond_value_index);
  return builder_.Finish();
}

struct FreeCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FreeCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_INDEX = 4
  };
  int32_t value_index() const {
    return GetField<int32_t>(VT_VALUE_INDEX, 0);
  }
  bool mutate_value_index(int32_t _value_index = 0) {
    return SetField<int32_t>(VT_VALUE_INDEX, _value_index, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct FreeCallBuilder {
  typedef FreeCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_index(int32_t value_index) {
    fbb_.AddElement<int32_t>(FreeCall::VT_VALUE_INDEX, value_index, 0);
  }
  explicit FreeCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FreeCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FreeCall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FreeCall> CreateFreeCall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value_index = 0) {
  FreeCallBuilder builder_(_fbb);
  builder_.add_value_index(value_index);
  return builder_.Finish();
}

struct Instruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTR_ARGS_TYPE = 4,
    VT_INSTR_ARGS = 6
  };
  executorch_flatbuffer::InstructionArguments instr_args_type() const {
    return static_cast<executorch_flatbuffer::InstructionArguments>(GetField<uint8_t>(VT_INSTR_ARGS_TYPE, 0));
  }
  const void *instr_args() const {
    return GetPointer<const void *>(VT_INSTR_ARGS);
  }
  template<typename T> const T *instr_args_as() const;
  const executorch_flatbuffer::KernelCall *instr_args_as_KernelCall() const {
    return instr_args_type() == executorch_flatbuffer::InstructionArguments::KernelCall ? static_cast<const executorch_flatbuffer::KernelCall *>(instr_args()) : nullptr;
  }
  const executorch_flatbuffer::DelegateCall *instr_args_as_DelegateCall() const {
    return instr_args_type() == executorch_flatbuffer::InstructionArguments::DelegateCall ? static_cast<const executorch_flatbuffer::DelegateCall *>(instr_args()) : nullptr;
  }
  const executorch_flatbuffer::MoveCall *instr_args_as_MoveCall() const {
    return instr_args_type() == executorch_flatbuffer::InstructionArguments::MoveCall ? static_cast<const executorch_flatbuffer::MoveCall *>(instr_args()) : nullptr;
  }
  const executorch_flatbuffer::JumpFalseCall *instr_args_as_JumpFalseCall() const {
    return instr_args_type() == executorch_flatbuffer::InstructionArguments::JumpFalseCall ? static_cast<const executorch_flatbuffer::JumpFalseCall *>(instr_args()) : nullptr;
  }
  const executorch_flatbuffer::FreeCall *instr_args_as_FreeCall() const {
    return instr_args_type() == executorch_flatbuffer::InstructionArguments::FreeCall ? static_cast<const executorch_flatbuffer::FreeCall *>(instr_args()) : nullptr;
  }
  void *mutable_instr_args() {
    return GetPointer<void *>(VT_INSTR_ARGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INSTR_ARGS_TYPE, 1) &&
           VerifyOffset(verifier, VT_INSTR_ARGS) &&
           VerifyInstructionArguments(verifier, instr_args(), instr_args_type()) &&
           verifier.EndTable();
  }
};

template<> inline const executorch_flatbuffer::KernelCall *Instruction::instr_args_as<executorch_flatbuffer::KernelCall>() const {
  return instr_args_as_KernelCall();
}

template<> inline const executorch_flatbuffer::DelegateCall *Instruction::instr_args_as<executorch_flatbuffer::DelegateCall>() const {
  return instr_args_as_DelegateCall();
}

template<> inline const executorch_flatbuffer::MoveCall *Instruction::instr_args_as<executorch_flatbuffer::MoveCall>() const {
  return instr_args_as_MoveCall();
}

template<> inline const executorch_flatbuffer::JumpFalseCall *Instruction::instr_args_as<executorch_flatbuffer::JumpFalseCall>() const {
  return instr_args_as_JumpFalseCall();
}

template<> inline const executorch_flatbuffer::FreeCall *Instruction::instr_args_as<executorch_flatbuffer::FreeCall>() const {
  return instr_args_as_FreeCall();
}

struct InstructionBuilder {
  typedef Instruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instr_args_type(executorch_flatbuffer::InstructionArguments instr_args_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_INSTR_ARGS_TYPE, static_cast<uint8_t>(instr_args_type), 0);
  }
  void add_instr_args(::flatbuffers::Offset<void> instr_args) {
    fbb_.AddOffset(Instruction::VT_INSTR_ARGS, instr_args);
  }
  explicit InstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Instruction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Instruction> CreateInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    executorch_flatbuffer::InstructionArguments instr_args_type = executorch_flatbuffer::InstructionArguments::NONE,
    ::flatbuffers::Offset<void> instr_args = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_instr_args(instr_args);
  builder_.add_instr_args_type(instr_args_type);
  return builder_.Finish();
}

struct Frame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_LINENO = 6,
    VT_NAME = 8,
    VT_CONTEXT = 10
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  ::flatbuffers::String *mutable_filename() {
    return GetPointer<::flatbuffers::String *>(VT_FILENAME);
  }
  int32_t lineno() const {
    return GetField<int32_t>(VT_LINENO, 0);
  }
  bool mutate_lineno(int32_t _lineno = 0) {
    return SetField<int32_t>(VT_LINENO, _lineno, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *context() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTEXT);
  }
  ::flatbuffers::String *mutable_context() {
    return GetPointer<::flatbuffers::String *>(VT_CONTEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<int32_t>(verifier, VT_LINENO, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyString(context()) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  typedef Frame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(Frame::VT_FILENAME, filename);
  }
  void add_lineno(int32_t lineno) {
    fbb_.AddElement<int32_t>(Frame::VT_LINENO, lineno, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Frame::VT_NAME, name);
  }
  void add_context(::flatbuffers::Offset<::flatbuffers::String> context) {
    fbb_.AddOffset(Frame::VT_CONTEXT, context);
  }
  explicit FrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Frame> CreateFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    int32_t lineno = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> context = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_context(context);
  builder_.add_name(name);
  builder_.add_lineno(lineno);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Frame> CreateFrameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    int32_t lineno = 0,
    const char *name = nullptr,
    const char *context = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto context__ = context ? _fbb.CreateString(context) : 0;
  return executorch_flatbuffer::CreateFrame(
      _fbb,
      filename__,
      lineno,
      name__,
      context__);
}

struct FrameList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>> *>(VT_ITEMS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>> *mutable_items() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct FrameListBuilder {
  typedef FrameList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>>> items) {
    fbb_.AddOffset(FrameList::VT_ITEMS, items);
  }
  explicit FrameListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FrameList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FrameList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FrameList> CreateFrameList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>>> items = 0) {
  FrameListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FrameList> CreateFrameListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::Frame>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::Frame>>(*items) : 0;
  return executorch_flatbuffer::CreateFrameList(
      _fbb,
      items__);
}

struct BackendDelegateDataReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BackendDelegateDataReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION = 4,
    VT_INDEX = 6
  };
  executorch_flatbuffer::DataLocation location() const {
    return static_cast<executorch_flatbuffer::DataLocation>(GetField<int8_t>(VT_LOCATION, 0));
  }
  bool mutate_location(executorch_flatbuffer::DataLocation _location = static_cast<executorch_flatbuffer::DataLocation>(0)) {
    return SetField<int8_t>(VT_LOCATION, static_cast<int8_t>(_location), 0);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool mutate_index(uint32_t _index = 0) {
    return SetField<uint32_t>(VT_INDEX, _index, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LOCATION, 1) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct BackendDelegateDataReferenceBuilder {
  typedef BackendDelegateDataReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_location(executorch_flatbuffer::DataLocation location) {
    fbb_.AddElement<int8_t>(BackendDelegateDataReference::VT_LOCATION, static_cast<int8_t>(location), 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(BackendDelegateDataReference::VT_INDEX, index, 0);
  }
  explicit BackendDelegateDataReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BackendDelegateDataReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BackendDelegateDataReference>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BackendDelegateDataReference> CreateBackendDelegateDataReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    executorch_flatbuffer::DataLocation location = executorch_flatbuffer::DataLocation::INLINE,
    uint32_t index = 0) {
  BackendDelegateDataReferenceBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_location(location);
  return builder_.Finish();
}

struct CompileSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompileSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct CompileSpecBuilder {
  typedef CompileSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(CompileSpec::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(CompileSpec::VT_VALUE, value);
  }
  explicit CompileSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompileSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompileSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompileSpec> CreateCompileSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {
  CompileSpecBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompileSpec> CreateCompileSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return executorch_flatbuffer::CreateCompileSpec(
      _fbb,
      key__,
      value__);
}

struct BackendDelegate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BackendDelegateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROCESSED = 6,
    VT_COMPILE_SPECS = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  ::flatbuffers::String *mutable_id() {
    return GetPointer<::flatbuffers::String *>(VT_ID);
  }
  const executorch_flatbuffer::BackendDelegateDataReference *processed() const {
    return GetPointer<const executorch_flatbuffer::BackendDelegateDataReference *>(VT_PROCESSED);
  }
  executorch_flatbuffer::BackendDelegateDataReference *mutable_processed() {
    return GetPointer<executorch_flatbuffer::BackendDelegateDataReference *>(VT_PROCESSED);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>> *compile_specs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>> *>(VT_COMPILE_SPECS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>> *mutable_compile_specs() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>> *>(VT_COMPILE_SPECS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PROCESSED) &&
           verifier.VerifyTable(processed()) &&
           VerifyOffset(verifier, VT_COMPILE_SPECS) &&
           verifier.VerifyVector(compile_specs()) &&
           verifier.VerifyVectorOfTables(compile_specs()) &&
           verifier.EndTable();
  }
};

struct BackendDelegateBuilder {
  typedef BackendDelegate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(BackendDelegate::VT_ID, id);
  }
  void add_processed(::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateDataReference> processed) {
    fbb_.AddOffset(BackendDelegate::VT_PROCESSED, processed);
  }
  void add_compile_specs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>>> compile_specs) {
    fbb_.AddOffset(BackendDelegate::VT_COMPILE_SPECS, compile_specs);
  }
  explicit BackendDelegateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BackendDelegate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BackendDelegate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BackendDelegate> CreateBackendDelegate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateDataReference> processed = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>>> compile_specs = 0) {
  BackendDelegateBuilder builder_(_fbb);
  builder_.add_compile_specs(compile_specs);
  builder_.add_processed(processed);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BackendDelegate> CreateBackendDelegateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    ::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateDataReference> processed = 0,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>> *compile_specs = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto compile_specs__ = compile_specs ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::CompileSpec>>(*compile_specs) : 0;
  return executorch_flatbuffer::CreateBackendDelegate(
      _fbb,
      id__,
      processed,
      compile_specs__);
}

struct Chain FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_INSTRUCTIONS = 8,
    VT_STACKTRACE = 10
  };
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_inputs() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_outputs() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>> *instructions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>> *>(VT_INSTRUCTIONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>> *mutable_instructions() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>> *>(VT_INSTRUCTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>> *stacktrace() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>> *>(VT_STACKTRACE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>> *mutable_stacktrace() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>> *>(VT_STACKTRACE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(instructions()) &&
           verifier.VerifyVectorOfTables(instructions()) &&
           VerifyOffset(verifier, VT_STACKTRACE) &&
           verifier.VerifyVector(stacktrace()) &&
           verifier.VerifyVectorOfTables(stacktrace()) &&
           verifier.EndTable();
  }
};

struct ChainBuilder {
  typedef Chain Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Chain::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Chain::VT_OUTPUTS, outputs);
  }
  void add_instructions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>>> instructions) {
    fbb_.AddOffset(Chain::VT_INSTRUCTIONS, instructions);
  }
  void add_stacktrace(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>>> stacktrace) {
    fbb_.AddOffset(Chain::VT_STACKTRACE, stacktrace);
  }
  explicit ChainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chain>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chain> CreateChain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>>> instructions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>>> stacktrace = 0) {
  ChainBuilder builder_(_fbb);
  builder_.add_stacktrace(stacktrace);
  builder_.add_instructions(instructions);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chain> CreateChainDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>> *instructions = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>> *stacktrace = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto instructions__ = instructions ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::Instruction>>(*instructions) : 0;
  auto stacktrace__ = stacktrace ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::FrameList>>(*stacktrace) : 0;
  return executorch_flatbuffer::CreateChain(
      _fbb,
      inputs__,
      outputs__,
      instructions__,
      stacktrace__);
}

struct ExecutionPlan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExecutionPlanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CONTAINER_META_TYPE = 6,
    VT_VALUES = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12,
    VT_CHAINS = 14,
    VT_OPERATORS = 16,
    VT_DELEGATES = 18,
    VT_NON_CONST_BUFFER_SIZES = 20
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  const executorch_flatbuffer::ContainerMetadata *container_meta_type() const {
    return GetPointer<const executorch_flatbuffer::ContainerMetadata *>(VT_CONTAINER_META_TYPE);
  }
  executorch_flatbuffer::ContainerMetadata *mutable_container_meta_type() {
    return GetPointer<executorch_flatbuffer::ContainerMetadata *>(VT_CONTAINER_META_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>> *>(VT_VALUES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>> *mutable_values() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>> *>(VT_VALUES);
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_inputs() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_outputs() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>> *chains() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>> *>(VT_CHAINS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>> *mutable_chains() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>> *>(VT_CHAINS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>> *operators() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>> *>(VT_OPERATORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>> *mutable_operators() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>> *>(VT_OPERATORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>> *delegates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>> *>(VT_DELEGATES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>> *mutable_delegates() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>> *>(VT_DELEGATES);
  }
  const ::flatbuffers::Vector<int64_t> *non_const_buffer_sizes() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_NON_CONST_BUFFER_SIZES);
  }
  ::flatbuffers::Vector<int64_t> *mutable_non_const_buffer_sizes() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_NON_CONST_BUFFER_SIZES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CONTAINER_META_TYPE) &&
           verifier.VerifyTable(container_meta_type()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_CHAINS) &&
           verifier.VerifyVector(chains()) &&
           verifier.VerifyVectorOfTables(chains()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_DELEGATES) &&
           verifier.VerifyVector(delegates()) &&
           verifier.VerifyVectorOfTables(delegates()) &&
           VerifyOffset(verifier, VT_NON_CONST_BUFFER_SIZES) &&
           verifier.VerifyVector(non_const_buffer_sizes()) &&
           verifier.EndTable();
  }
};

struct ExecutionPlanBuilder {
  typedef ExecutionPlan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ExecutionPlan::VT_NAME, name);
  }
  void add_container_meta_type(::flatbuffers::Offset<executorch_flatbuffer::ContainerMetadata> container_meta_type) {
    fbb_.AddOffset(ExecutionPlan::VT_CONTAINER_META_TYPE, container_meta_type);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>>> values) {
    fbb_.AddOffset(ExecutionPlan::VT_VALUES, values);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(ExecutionPlan::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(ExecutionPlan::VT_OUTPUTS, outputs);
  }
  void add_chains(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>>> chains) {
    fbb_.AddOffset(ExecutionPlan::VT_CHAINS, chains);
  }
  void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>>> operators) {
    fbb_.AddOffset(ExecutionPlan::VT_OPERATORS, operators);
  }
  void add_delegates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>>> delegates) {
    fbb_.AddOffset(ExecutionPlan::VT_DELEGATES, delegates);
  }
  void add_non_const_buffer_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> non_const_buffer_sizes) {
    fbb_.AddOffset(ExecutionPlan::VT_NON_CONST_BUFFER_SIZES, non_const_buffer_sizes);
  }
  explicit ExecutionPlanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExecutionPlan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExecutionPlan>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExecutionPlan> CreateExecutionPlan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<executorch_flatbuffer::ContainerMetadata> container_meta_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>>> values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>>> chains = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>>> operators = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>>> delegates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> non_const_buffer_sizes = 0) {
  ExecutionPlanBuilder builder_(_fbb);
  builder_.add_non_const_buffer_sizes(non_const_buffer_sizes);
  builder_.add_delegates(delegates);
  builder_.add_operators(operators);
  builder_.add_chains(chains);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_values(values);
  builder_.add_container_meta_type(container_meta_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ExecutionPlan> CreateExecutionPlanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<executorch_flatbuffer::ContainerMetadata> container_meta_type = 0,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::EValue>> *values = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::Chain>> *chains = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::Operator>> *operators = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>> *delegates = nullptr,
    const std::vector<int64_t> *non_const_buffer_sizes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::EValue>>(*values) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto chains__ = chains ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::Chain>>(*chains) : 0;
  auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::Operator>>(*operators) : 0;
  auto delegates__ = delegates ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegate>>(*delegates) : 0;
  auto non_const_buffer_sizes__ = non_const_buffer_sizes ? _fbb.CreateVector<int64_t>(*non_const_buffer_sizes) : 0;
  return executorch_flatbuffer::CreateExecutionPlan(
      _fbb,
      name__,
      container_meta_type,
      values__,
      inputs__,
      outputs__,
      chains__,
      operators__,
      delegates__,
      non_const_buffer_sizes__);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORAGE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *storage() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_STORAGE);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_storage() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_STORAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STORAGE) &&
           verifier.VerifyVector(storage()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_storage(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> storage) {
    fbb_.AddOffset(Buffer::VT_STORAGE, storage);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> storage = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_storage(storage);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *storage = nullptr) {
  if (storage) { _fbb.ForceVectorAlignment(storage->size(), sizeof(uint8_t), 16); }
  auto storage__ = storage ? _fbb.CreateVector<uint8_t>(*storage) : 0;
  return executorch_flatbuffer::CreateBuffer(
      _fbb,
      storage__);
}

struct BackendDelegateInlineData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BackendDelegateInlineDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BackendDelegateInlineDataBuilder {
  typedef BackendDelegateInlineData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(BackendDelegateInlineData::VT_DATA, data);
  }
  explicit BackendDelegateInlineDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BackendDelegateInlineData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BackendDelegateInlineData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BackendDelegateInlineData> CreateBackendDelegateInlineData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  BackendDelegateInlineDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BackendDelegateInlineData> CreateBackendDelegateInlineDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return executorch_flatbuffer::CreateBackendDelegateInlineData(
      _fbb,
      data__);
}

struct DataSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_SIZE = 6
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(uint64_t _offset = 0) {
    return SetField<uint64_t>(VT_OFFSET, _offset, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint64_t _size = 0) {
    return SetField<uint64_t>(VT_SIZE, _size, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
};

struct DataSegmentBuilder {
  typedef DataSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(DataSegment::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(DataSegment::VT_SIZE, size, 0);
  }
  explicit DataSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataSegment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataSegment> CreateDataSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0,
    uint64_t size = 0) {
  DataSegmentBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct SubsegmentOffsets FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubsegmentOffsetsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT_INDEX = 4,
    VT_OFFSETS = 6
  };
  uint32_t segment_index() const {
    return GetField<uint32_t>(VT_SEGMENT_INDEX, 0);
  }
  bool mutate_segment_index(uint32_t _segment_index = 0) {
    return SetField<uint32_t>(VT_SEGMENT_INDEX, _segment_index, 0);
  }
  const ::flatbuffers::Vector<uint64_t> *offsets() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_OFFSETS);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_offsets() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_OFFSETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_INDEX, 4) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           verifier.EndTable();
  }
};

struct SubsegmentOffsetsBuilder {
  typedef SubsegmentOffsets Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_segment_index(uint32_t segment_index) {
    fbb_.AddElement<uint32_t>(SubsegmentOffsets::VT_SEGMENT_INDEX, segment_index, 0);
  }
  void add_offsets(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> offsets) {
    fbb_.AddOffset(SubsegmentOffsets::VT_OFFSETS, offsets);
  }
  explicit SubsegmentOffsetsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubsegmentOffsets> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubsegmentOffsets>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubsegmentOffsets> CreateSubsegmentOffsets(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t segment_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> offsets = 0) {
  SubsegmentOffsetsBuilder builder_(_fbb);
  builder_.add_offsets(offsets);
  builder_.add_segment_index(segment_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubsegmentOffsets> CreateSubsegmentOffsetsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t segment_index = 0,
    const std::vector<uint64_t> *offsets = nullptr) {
  auto offsets__ = offsets ? _fbb.CreateVector<uint64_t>(*offsets) : 0;
  return executorch_flatbuffer::CreateSubsegmentOffsets(
      _fbb,
      segment_index,
      offsets__);
}

struct Program FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProgramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_EXECUTION_PLAN = 6,
    VT_CONSTANT_BUFFER = 8,
    VT_BACKEND_DELEGATE_DATA = 10,
    VT_SEGMENTS = 12,
    VT_CONSTANT_SEGMENT = 14
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version = 0) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>> *execution_plan() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>> *>(VT_EXECUTION_PLAN);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>> *mutable_execution_plan() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>> *>(VT_EXECUTION_PLAN);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>> *constant_buffer() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>> *>(VT_CONSTANT_BUFFER);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>> *mutable_constant_buffer() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>> *>(VT_CONSTANT_BUFFER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>> *backend_delegate_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>> *>(VT_BACKEND_DELEGATE_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>> *mutable_backend_delegate_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>> *>(VT_BACKEND_DELEGATE_DATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>> *segments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>> *>(VT_SEGMENTS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>> *mutable_segments() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>> *>(VT_SEGMENTS);
  }
  const executorch_flatbuffer::SubsegmentOffsets *constant_segment() const {
    return GetPointer<const executorch_flatbuffer::SubsegmentOffsets *>(VT_CONSTANT_SEGMENT);
  }
  executorch_flatbuffer::SubsegmentOffsets *mutable_constant_segment() {
    return GetPointer<executorch_flatbuffer::SubsegmentOffsets *>(VT_CONSTANT_SEGMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_EXECUTION_PLAN) &&
           verifier.VerifyVector(execution_plan()) &&
           verifier.VerifyVectorOfTables(execution_plan()) &&
           VerifyOffset(verifier, VT_CONSTANT_BUFFER) &&
           verifier.VerifyVector(constant_buffer()) &&
           verifier.VerifyVectorOfTables(constant_buffer()) &&
           VerifyOffset(verifier, VT_BACKEND_DELEGATE_DATA) &&
           verifier.VerifyVector(backend_delegate_data()) &&
           verifier.VerifyVectorOfTables(backend_delegate_data()) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           VerifyOffset(verifier, VT_CONSTANT_SEGMENT) &&
           verifier.VerifyTable(constant_segment()) &&
           verifier.EndTable();
  }
};

struct ProgramBuilder {
  typedef Program Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Program::VT_VERSION, version, 0);
  }
  void add_execution_plan(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>>> execution_plan) {
    fbb_.AddOffset(Program::VT_EXECUTION_PLAN, execution_plan);
  }
  void add_constant_buffer(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>>> constant_buffer) {
    fbb_.AddOffset(Program::VT_CONSTANT_BUFFER, constant_buffer);
  }
  void add_backend_delegate_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>>> backend_delegate_data) {
    fbb_.AddOffset(Program::VT_BACKEND_DELEGATE_DATA, backend_delegate_data);
  }
  void add_segments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>>> segments) {
    fbb_.AddOffset(Program::VT_SEGMENTS, segments);
  }
  void add_constant_segment(::flatbuffers::Offset<executorch_flatbuffer::SubsegmentOffsets> constant_segment) {
    fbb_.AddOffset(Program::VT_CONSTANT_SEGMENT, constant_segment);
  }
  explicit ProgramBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Program> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Program>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Program> CreateProgram(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>>> execution_plan = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>>> constant_buffer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>>> backend_delegate_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>>> segments = 0,
    ::flatbuffers::Offset<executorch_flatbuffer::SubsegmentOffsets> constant_segment = 0) {
  ProgramBuilder builder_(_fbb);
  builder_.add_constant_segment(constant_segment);
  builder_.add_segments(segments);
  builder_.add_backend_delegate_data(backend_delegate_data);
  builder_.add_constant_buffer(constant_buffer);
  builder_.add_execution_plan(execution_plan);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Program> CreateProgramDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>> *execution_plan = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>> *constant_buffer = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>> *backend_delegate_data = nullptr,
    const std::vector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>> *segments = nullptr,
    ::flatbuffers::Offset<executorch_flatbuffer::SubsegmentOffsets> constant_segment = 0) {
  auto execution_plan__ = execution_plan ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::ExecutionPlan>>(*execution_plan) : 0;
  auto constant_buffer__ = constant_buffer ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::Buffer>>(*constant_buffer) : 0;
  auto backend_delegate_data__ = backend_delegate_data ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::BackendDelegateInlineData>>(*backend_delegate_data) : 0;
  auto segments__ = segments ? _fbb.CreateVector<::flatbuffers::Offset<executorch_flatbuffer::DataSegment>>(*segments) : 0;
  return executorch_flatbuffer::CreateProgram(
      _fbb,
      version,
      execution_plan__,
      constant_buffer__,
      backend_delegate_data__,
      segments__,
      constant_segment);
}

inline bool VerifyKernelTypes(::flatbuffers::Verifier &verifier, const void *obj, KernelTypes type) {
  switch (type) {
    case KernelTypes::NONE: {
      return true;
    }
    case KernelTypes::Null: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::Null *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::Int: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::Bool: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::Double: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::Tensor: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::String: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::IntList: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::IntList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::DoubleList: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::DoubleList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::BoolList: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::BoolList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::TensorList: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::TensorList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KernelTypes::OptionalTensorList: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::OptionalTensorList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyKernelTypesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<KernelTypes> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyKernelTypes(
        verifier,  values->Get(i), types->GetEnum<KernelTypes>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyInstructionArguments(::flatbuffers::Verifier &verifier, const void *obj, InstructionArguments type) {
  switch (type) {
    case InstructionArguments::NONE: {
      return true;
    }
    case InstructionArguments::KernelCall: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::KernelCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InstructionArguments::DelegateCall: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::DelegateCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InstructionArguments::MoveCall: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::MoveCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InstructionArguments::JumpFalseCall: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::JumpFalseCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InstructionArguments::FreeCall: {
      auto ptr = reinterpret_cast<const executorch_flatbuffer::FreeCall *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInstructionArgumentsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<InstructionArguments> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInstructionArguments(
        verifier,  values->Get(i), types->GetEnum<InstructionArguments>(i))) {
      return false;
    }
  }
  return true;
}

inline const executorch_flatbuffer::Program *GetProgram(const void *buf) {
  return ::flatbuffers::GetRoot<executorch_flatbuffer::Program>(buf);
}

inline const executorch_flatbuffer::Program *GetSizePrefixedProgram(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<executorch_flatbuffer::Program>(buf);
}

inline Program *GetMutableProgram(void *buf) {
  return ::flatbuffers::GetMutableRoot<Program>(buf);
}

inline executorch_flatbuffer::Program *GetMutableSizePrefixedProgram(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<executorch_flatbuffer::Program>(buf);
}

inline const char *ProgramIdentifier() {
  return "ET12";
}

inline bool ProgramBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ProgramIdentifier());
}

inline bool SizePrefixedProgramBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ProgramIdentifier(), true);
}

inline bool VerifyProgramBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<executorch_flatbuffer::Program>(ProgramIdentifier());
}

inline bool VerifySizePrefixedProgramBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<executorch_flatbuffer::Program>(ProgramIdentifier());
}

inline const char *ProgramExtension() {
  return "pte";
}

inline void FinishProgramBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<executorch_flatbuffer::Program> root) {
  fbb.Finish(root, ProgramIdentifier());
}

inline void FinishSizePrefixedProgramBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<executorch_flatbuffer::Program> root) {
  fbb.FinishSizePrefixed(root, ProgramIdentifier());
}

}  // namespace executorch_flatbuffer

#endif  // FLATBUFFERS_GENERATED_PROGRAM_EXECUTORCH_FLATBUFFER_H_
