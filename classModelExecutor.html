<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed Torch Fusion OS: ModelExecutor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mbed Torch Fusion OS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classModelExecutor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ModelExecutor Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71db00db11b79c6488c7b515490f6d24" id="r_a71db00db11b79c6488c7b515490f6d24"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModelExecutor.html#a71db00db11b79c6488c7b515490f6d24">run_model</a> (std::vector&lt; float &gt; feature_vector)</td></tr>
<tr class="separator:a71db00db11b79c6488c7b515490f6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadb3efddb8597f7f91d84199543d02a" id="r_afadb3efddb8597f7f91d84199543d02a"><td class="memItemLeft" align="right" valign="top"><a id="afadb3efddb8597f7f91d84199543d02a" name="afadb3efddb8597f7f91d84199543d02a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ModelExecutor</b> (const <a class="el" href="classModelExecutor.html">ModelExecutor</a> &amp;)=delete</td></tr>
<tr class="separator:afadb3efddb8597f7f91d84199543d02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7d9571d08fd84e3e9f11ad1fe3cd2b" id="r_a5f7d9571d08fd84e3e9f11ad1fe3cd2b"><td class="memItemLeft" align="right" valign="top"><a id="a5f7d9571d08fd84e3e9f11ad1fe3cd2b" name="a5f7d9571d08fd84e3e9f11ad1fe3cd2b"></a>
<a class="el" href="classModelExecutor.html">ModelExecutor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classModelExecutor.html">ModelExecutor</a> &amp;)=delete</td></tr>
<tr class="separator:a5f7d9571d08fd84e3e9f11ad1fe3cd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0fc9536f4585e5ec8c95fa449a54faa8" id="r_a0fc9536f4585e5ec8c95fa449a54faa8"><td class="memItemLeft" align="right" valign="top"><a id="a0fc9536f4585e5ec8c95fa449a54faa8" name="a0fc9536f4585e5ec8c95fa449a54faa8"></a>
static <a class="el" href="classModelExecutor.html">ModelExecutor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstance</b> (size_t pool_size=512)</td></tr>
<tr class="separator:a0fc9536f4585e5ec8c95fa449a54faa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71db00db11b79c6488c7b515490f6d24" name="a71db00db11b79c6488c7b515490f6d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71db00db11b79c6488c7b515490f6d24">&#9670;&#160;</a></span>run_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; ModelExecutor::run_model </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>feature_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically allocating a block of memory on the heap and assigning the address of the allocated memory to the member variable m_method_allocator_pool</p>
<p>A DataLoader that wraps a pre-allocated buffer in network_model_sec. The FreeableBuffers that it returns do not actually free any data.</p>
<p>This can be used to wrap data that is directly embedded into the firmware image, or to wrap data that was allocated elsewhere.</p>
<p>A deserialized ExecuTorch program binary. Loads a Program from the provided loader. The Program will hold a pointer to the loader, which must outlive the returned Program instance.</p>
<p>Gathers metadata for the named method.</p>
<p>MemoryAllocator does simple allocation based on a size and returns the pointer to the memory address. It bookmarks a buffer with certain size. The allocation is simply checking space and growing the cur_ pointer with each allocation request.</p>
<p>Simple example:</p>
<p>// User allocates a 100 byte long memory in the heap. uint8_t* memory_pool = malloc(100 * sizeof(uint8_t)); MemoryAllocator allocator(100, memory_pool) // Pass allocator object in the Executor</p>
<p>Underneath the hood, ExecuTorch will call allocator.allocate() to keep iterating cur_ pointer</p>
<p>Stores unique pointers (std::unique_ptr) to dynamically allocated arrays of uint8_t. Owns the memory.</p>
<p>Represent a reference to an array (0 or more elements consecutively in memory), i.e. a start pointer and a length. It allows various APIs to take consecutive elements easily and conveniently.</p>
<p>This class does not own the underlying data, it is expected to be used in situations where the data resides in some other buffer, whose lifetime extends past that of the Span.</p>
<p>Span and ArrayRef are extrememly similar with the difference being ArrayRef views a list of constant elements and Span views a list of mutable elements. Clients should decide between the two based on if the list elements for their use case should be mutable.</p>
<p>This is intended to be trivially copyable, so it should be passed by value.</p>
<p>Passed to the allocator</p>
<p>Get the number of memory-planned buffers this method requires.</p>
<p>Get the size in bytes of the specified memory-planned buffer. Can only be changed in network definition (Python). Before exporting model.pte</p>
<p>Dynamically allocates buffer_size bytes on the heap using std::make_unique&lt;uint8_t[]&gt;, creating a std::unique_ptr to manage this memory. The std::unique_ptr is then moved into the planned_buffers container, transferring ownership of the heap-allocated memory to the container. No memory leaks since std::unique_ptr in planned_buffers owns the heap-allocated memory and deletes the memory when the unique_ptr is destroyed (e.g., when the vector is cleared, resized, or goes out of scope).</p>
<p>Simply provides a lightweight view over the existing heap-allocated planned_buffers without taking ownership.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/model_executor/<a class="el" href="ModelExecutor_8h_source.html">ModelExecutor.h</a></li>
<li>src/model_executor/<b>ModelExecutor.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
